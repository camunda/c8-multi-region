---
name: reusable_teleport_operational_procedure

on:
    workflow_call:
        inputs:
            helmChartVersion:
                type: string
                description: Version of the Helm chart to deploy.
                required: false
                default: 11.1.0

            helmChartName:
                description: Optional Helm chart name
                required: false
                type: string

            globalImageTag:
                description: Optional global image tag
                required: false
                type: string

            awsProfile:
                description: AWS profile to use
                required: false
                type: string
                default: infex

            testsTfBinaryName:
                description: Terraform binary name for tests
                required: false
                type: string
                default: terraform

            namespacePrefix:
                description: Prefix for namespaces
                required: false
                type: string
                default: infraex-

            clusterName:
                description: EKS cluster name
                required: false
                type: string
                default: camunda-ci-eks

            labels:
                description: Labels to apply
                required: false
                type: string
                default: janitor/ttl=1h camunda.cloud/ephemeral=true

            cluster:
                description: Cluster identifier (same for Cluster 0 & 1)
                required: false
                type: string
                default: camunda.teleport.sh-camunda-ci-eks

            backupBucket:
                description: Backup bucket name
                required: false
                type: string
                default: tests-c8-multi-region-es-eu-central-1

            helmReleaseName:
                description: Helm release name
                required: false
                type: string
                default: camunda

            zeebeClusterSize:
                description: Zeebe cluster size
                required: false
                type: number
                default: 8

        secrets:
            VAULT_ADDR:
                required: true
            VAULT_ROLE_ID:
                required: true
            VAULT_SECRET_ID:
                required: true

permissions:
    contents: read
    id-token: write

env:
    AWS_PROFILE: ${{ inputs.awsProfile }}
    TESTS_TF_BINARY_NAME: ${{ inputs.testsTfBinaryName }}
    NAMESPACE_PREFIX: ${{ inputs.namespacePrefix }}
    CLUSTER_NAME: ${{ inputs.clusterName }}
    LABELS: ${{ inputs.labels }}

    # Single input used for both cluster variables (to be able to reuse dual cluster tests)
    CLUSTER_0: ${{ inputs.cluster }}
    CLUSTER_1: ${{ inputs.cluster }}

    KUBECONFIG: ./kubeconfig

    BACKUP_BUCKET: ${{ inputs.backupBucket }}
    HELM_RELEASE_NAME: ${{ inputs.helmReleaseName }}
    ZEEBE_CLUSTER_SIZE: ${{ inputs.zeebeClusterSize }}
    HELM_CHART_VERSION: ${{ inputs.helmChartVersion }}


jobs:
    teleport-setup:
        runs-on: ubuntu-latest

        steps:
            - name: Set optional environment variables conditionally
              run: |
                  if [ -n "${{ inputs.helmChartName }}" ]; then
                    echo "HELM_CHART_NAME=${{ inputs.helmChartName }}" >> "$GITHUB_ENV"
                  fi
                  if [ -n "${{ inputs.globalImageTag }}" ]; then
                    echo "GLOBAL_IMAGE_TAG=${{ inputs.globalImageTag }}" >> "$GITHUB_ENV"
                  fi

            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Setup AWS and Tools
              uses: ./.github/actions/setup-aws
              with:
                  secrets: ${{ toJSON(secrets) }}

            - name: Set up Teleport
              uses: teleport-actions/setup@v1
              with:
                  version: 16.4.11

            - name: Authenticate with Teleport
              uses: teleport-actions/auth-k8s@v2
              with:
                  proxy: camunda.teleport.sh:443
                  token: infra-ci-prod-github-action-infraex
                  kubernetes-cluster: camunda-ci-eks

            - name: Write kubeconfig file
              id: write-kubeconfig
              run: |
                  kubectl config view --raw > ./test/kubeconfig

            - name: Update namespace arrays with prefix and random suffix
              id: update-namespace-arrays
              run: |
                  set -euxo pipefail

                  RANDOM_ID="$(openssl rand -hex 3)"

                  echo "BACKUP_NAME=$RANDOM_ID" >> "$GITHUB_ENV"

                  update_namespace_array() {
                    local arr="$1"
                    local new_arr=""
                    IFS=',' read -r -a ADDR <<< "$arr"
                    for i in "${ADDR[@]}"; do
                      new_arr+="${NAMESPACE_PREFIX}${i}-${RANDOM_ID},"
                    done
                    # Remove trailing comma
                    echo "${new_arr%,}"
                  }

                  CLUSTER_1_NAMESPACE_ARR_UPDATED="$(update_namespace_array "${CLUSTER_1_NAMESPACE_ARR}")"
                  CLUSTER_1_NAMESPACE_FAILOVER_ARR_UPDATED="$(update_namespace_array "${CLUSTER_1_NAMESPACE_FAILOVER_ARR}")"
                  CLUSTER_0_NAMESPACE_ARR_UPDATED="$(update_namespace_array "${CLUSTER_0_NAMESPACE_ARR}")"
                  CLUSTER_0_NAMESPACE_FAILOVER_ARR_UPDATED="$(update_namespace_array "${CLUSTER_0_NAMESPACE_FAILOVER_ARR}")"

                  {
                    echo "CLUSTER_1_NAMESPACE_ARR=$CLUSTER_1_NAMESPACE_ARR_UPDATED"
                    echo "CLUSTER_1_NAMESPACE_FAILOVER_ARR=$CLUSTER_1_NAMESPACE_FAILOVER_ARR_UPDATED"
                    echo "CLUSTER_0_NAMESPACE_ARR=$CLUSTER_0_NAMESPACE_ARR_UPDATED"
                    echo "CLUSTER_0_NAMESPACE_FAILOVER_ARR=$CLUSTER_0_NAMESPACE_FAILOVER_ARR_UPDATED"
                  } >> "$GITHUB_ENV"

                  get_first_item() {
                    local arr="$1"
                    IFS=',' read -r -a ADDR <<< "$arr"
                    echo "${ADDR[0]}"
                  }

                  {
                    echo "CLUSTER_1_NAMESPACE=$(get_first_item "$CLUSTER_1_NAMESPACE_ARR_UPDATED")"
                    echo "CLUSTER_1_NAMESPACE_FAILOVER=$(get_first_item "$CLUSTER_1_NAMESPACE_FAILOVER_ARR_UPDATED")"
                    echo "CLUSTER_0_NAMESPACE=$(get_first_item "$CLUSTER_0_NAMESPACE_ARR_UPDATED")"
                    echo "CLUSTER_0_NAMESPACE_FAILOVER=$(get_first_item "$CLUSTER_0_NAMESPACE_FAILOVER_ARR_UPDATED")"
                    echo "CAMUNDA_NAMESPACE_0=$(get_first_item "$CLUSTER_0_NAMESPACE_ARR_UPDATED")"
                    echo "CAMUNDA_NAMESPACE_1=$(get_first_item "$CLUSTER_1_NAMESPACE_ARR_UPDATED")"
                  } >> "$GITHUB_ENV"

            - name: Import Secrets
              id: secrets
              uses: hashicorp/vault-action@v3
              with:
                  url: ${{ secrets.VAULT_ADDR }}
                  method: approle
                  roleId: ${{ secrets.VAULT_ROLE_ID }}
                  secretId: ${{ secrets.VAULT_SECRET_ID }}
                  exportEnv: true
                  secrets: |
                      secret/data/products/infrastructure-experience/ci/common AWS_ACCESS_KEY | S3_BACKUP_ACCESS_KEY;
                      secret/data/products/infrastructure-experience/ci/common AWS_SECRET_KEY | S3_BACKUP_SECRET_KEY;

            - name: Create namespaces and secrets
              id: create-namespaces
              env:
                  AWS_SECRET_ACCESS_KEY_ES: ${{ steps.secrets.outputs.S3_BACKUP_SECRET_KEY }}
                  AWS_ACCESS_KEY_ES: ${{ steps.secrets.outputs.S3_BACKUP_ACCESS_KEY }}
              working-directory: ./test
              run: |
                  set -euxo pipefail
                  go test --count=1 -v -timeout 9m -run TestClusterPrerequisitesTeleport

            - name: Label namespaces and secrets
              run: |
                  set -euxo pipefail

                  label_resources() {
                    local namespace="$1"
                    kubectl label namespace "$namespace" ${{ env.LABELS }} --overwrite
                    local secrets
                    secrets="$(kubectl get secrets -n "$namespace" -o jsonpath='{.items[*].metadata.name}')"
                    for secret in $secrets; do
                      kubectl label secret "$secret" -n "$namespace" ${{ env.LABELS }} --overwrite
                    done
                  }

                  # Combine cluster-0 and cluster-1 arrays into one comma-separated list
                  IFS=',' read -r -a ALL_NAMESPACES <<< "${CLUSTER_0_NAMESPACE_ARR},${CLUSTER_1_NAMESPACE_ARR}"
                  for namespace in "${ALL_NAMESPACES[@]}"; do
                    label_resources "$namespace"
                  done

            - name: Deploy dual region Camunda
              id: deploy-camunda
              working-directory: ./test
              run: |
                  set -euxo pipefail
                  go test --count=1 -v -timeout 30m -run TestAWSDeployDualRegCamundaTeleport

            - name: Camunda failover test procedure
              id: failover-camunda
              working-directory: ./test
              run: |
                  set -euxo pipefail
                  go test --count=1 -v -timeout 30m -run TestAWSDualRegFailover_8_6_plusTeleport

            - name: Camunda failback test procedure
              id: failback-camunda
              working-directory: ./test
              run: |
                  set -euxo pipefail
                  go test --count=1 -v -timeout 30m -run TestAWSDualRegFailback_8_6_plusTeleport

            - name: Delete namespaces
              if: ${{ always() }}
              run: |
                  set -euxo pipefail

                  delete_namespaces() {
                    local namespace_arr="$1"
                    IFS=',' read -r -a arr <<< "$namespace_arr"
                    for ns in "${arr[@]}"; do
                      kubectl delete namespace "$ns" || true
                    done
                  }

                  delete_namespaces "${CLUSTER_0_NAMESPACE_ARR}"
                  delete_namespaces "${CLUSTER_1_NAMESPACE_ARR}"
                  delete_namespaces "${CLUSTER_0_NAMESPACE_FAILOVER_ARR}"
                  delete_namespaces "${CLUSTER_1_NAMESPACE_FAILOVER_ARR}"
